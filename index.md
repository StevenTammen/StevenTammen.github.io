---
layout: layout
title: Home
---

<h1 class="center"> Home </h1>

## Recent Activity

01/22/18   Blog post: [Using PuTTY and Emacs' Tramp On Windows](#using-putty-and-emacs-tramp-on-windows) <br/>
01/20/18   Posted [configuration README](https://github.com/StevenTammen/config) on Github. Moved [worthy projects](https://steventammen.com/worthy-projects/) to a separate page. Started blog (see below). <br/>
01/12/18   Published [Reading List](https://steventammen.com/reading-list)<br/>
01/06/18   Worked on [Keyboard Layouts](https://steventammen.com/keyboard-layouts/) and [Keyboards](https://steventammen.com/keyboards/)<br/>
11/22/17   Slightly updated many pages. Worked a lot on [Backpacks](https://steventammen.com/backpacks/) <br/>
09/16/17   Worked on [Keyboard Layouts](https://steventammen.com/keyboard-layouts/) <br/>
09/06/17   Added [Keyboards](https://steventammen.com/keyboards/) <br/>

# Recent Blog Posts

## Starting Up A Blog

#### January 20, 2018

I've toyed with the idea of blogging for a while now. Part of my initial hesitancy was/is that blogs are these ugly static beasts wherein information never gets updated.

When doing most things in my life, I break patterns in "non-backwards-compatible" ways, as they say. I'll flip-flop positions, try new things that are exactly the opposite of things I'd previously tried, and go through quick iterative sprints, as much as possible, to figure out what "best" is in a given circumstance. In other words, when I'm in the "research and thought stage" for any particular topic, my views change with great frequency.

To the uninitiated this would seem like madness. How can you be fully convinced that X is best only to say 5 days later that X is rubbish and Y is much better? Is that not contradictory?

It's all about how you approach problem-solving, and mostly boils down to definition of terms. To me, "best" is a mapping of my subjective understanding onto objective reality. That is to say, there is an "objective best" that exists for a specific set of input parameters (what we might call circumstantial variables). Then there is the "best" that I have bumped in to at present. This latter "best" is the X that changes to Y. The former one may or may not be X or Y. It may not even exist at present.

If all this seems impenetrable and abstract, it's just to say that there are complications when translating shifting human thought into the likes of "blog posts." I obsessively update my thinking according to new data, and blog posts, if not prefaced with verbose disclaimers in the manner of "warning: this writing represents my views on 01/20/18, which may or may not have much to do with I think now" have the danger of presenting things as "done" without having a built in way to edit and refine them over time. Hence why I was sticking with "pages," which can be updated freely over time since they don't have dates attached to them.

However, as I've thought more about it, these things can co-exist. You can write blog posts representing your thought a particular moment in time without feeling like you have to keep the post updated... because if it gets to that point, you should probably write a page on it anyway and spell things out more thoroughly. Maintaining a semantic distinction between "immutable, snapshot content" (i.e., blog posts) and "dynamic, thorough content" (i.e., pages) makes it easy for me to document my day to day thought for myself (and others, by extension) through blogging, while also maintaining a "cutting edge" version of things in dynamic pages that get regular updates. So as long as no one gets the impression that blog posts are the end of what can be said about something, they can be a helpful addition to the site.

And this concludes blog post number one. Probably to be made into a real page at some point.


## Having A Website And Complications Therein

#### January 20, 2018

A question I have gotten from several people in the few months I've had my site up is "what's the point?" It's a good question.

### Table of Contents

- [Bad Reasons To Have a Website](#bad-reasons-to-have-a-website)
- [Good Reasons To Have a Website](#good-reasons-to-have-a-website)
- [Hypocrisy](#hypocrisy)
- [On Naming Websites](#on-naming-websites)
- [On Anonymity](#on-anonymity)

### Bad Reasons To Have a Website

First, some reasons I think are lame. A lot of people recommend you have a website to showcase your CV/Resume, your projects, and "what skills and experience you bring to the table." (You know the type of arguments, and the nauseating language employed therein).

To be perfectly honest, this is exactly the sort of corporate standardization and conformity that drives me nuts. In other words, this is *exactly the opposite of a good reason* for having your own website. Anyone who has been around me in real life knows that marketing and public relations are two of the things in life that make me legitimately wrathful. You can couch them in terms of "communicating the benefits of your product," "customer management," etc., but when it comes down to it, the disciplines teach you how to spin blatant lies and nonsense. They are mediums of unethical manipulation of vulnerable people that aren't aware of the bias in presentation, either due to systemic enforcement of ignorance by companies, the government, and so forth for selfish gain, or simply because they have never had the corruption of the system exposed to them in a stark, no-holds-barred, manner. See [here](https://steventammen.com/reading-list/#escaping-the-cave) for some recommended reading on the subject.

All this to say, I think it is a very bad idea to create a website and publish content solely to make yourself appear like a qualified, interesting person. That's falseness and insincerity, and if you do it, shame on you. With as little truth as there is in how we interact with each other nowadays, making up stuff to sound intelligent is all the more despicable. Particularly if it leads to you getting a job/promotion over a more qualified person who was unwilling to "play the game" of  truth twisting and self-aggrandizement.

Now, with that big one out of the way, here's a few other things to avoid:

- Hosting a website/writing to preach your views to others as holy dogma that must not be questioned.
- Hosting a website/writing to stir up resentment between groups of people (think politically, racially, etc.). In other words, demagoguery.
- Hosting a website/writing to insult, vilify, or harm any group of people, even if they are morally backwards and might kind of deserve it. Hate begets hate, not progress.
- Hosting a website/writing to troll others. Trolling is fun but not constructive.

I could go on, but you get the idea. Don't be evil/insensitive/rude. The prohibition against trolling bears repeating. It is satisfying to get people worked up without them knowing you are not serious, but it is more satisfying to help them see the truth of the matters that they are irrationally emotional about. (Taking pains to not become a white knight in so doing).

### Good Reasons To Have a Website

I found a quote that almost perfectly encapsulates my main reason for having a website. From the middle of [this excellent piece](http://paulgraham.com/hundred.html):

> The word "essay" comes from the French verb "essayer", which means "to try". An essay, in the original sense, is something you write to try to figure something out. This happens in software too. I think some of the best programs were essays, in the sense that the authors didn't know when they started exactly what they were trying to write.

In other words, I write for me. It's selfish. Getting everything "on paper" so that I can more clearly see relationships in information and reason about it helps me figure stuff out. Even if I weren't publishing things on the internet, I'd still do more or less do what I do, since it's how progress in thought is attained.

But there's benefit to publishing these "essays," these stabs at the truth. What are they, you ask? Well there are several:

- I'm kinda dumb sometimes. Other people are kinda smart sometimes. The synthesis of these means that I can learn a lot from what other people say/think about what I write.
  - This is basically what the open source movement is all about: multiple people lead to higher quality projects since sometimes we all make mistakes and benefit from others' perspectives.
- [No problem should ever have to be solved twice](http://www.catb.org/~esr/faqs/hacker-howto.html#believe2). (You should really read that all the way through. It's absolutely fantastic). Sharing knowledge is important.
- "Putting it out there" makes me take things more seriously because people can fact check me and contradict me if I'm wrong. Humans have a nasty habit of rationalizing their actions and committing intellectual suicide-by-self-justification. If I commit such sins when I lock up my writing in a journal, I'll never know. If I commit such sins when I publish something, someone is bound to tell me, either nicely and constructively, or gloatingly and rudely. Either way, I'll know that I messed up somewhere, and won't get trapped by self-delusion.

### Hypocrisy

An astute observer might note that I have actually published my CV/Resume on my website, and do mention my side projects in what I write. What gives then? I thought websites were to put your thoughts out there to make them better? How does posting such things help?

You see, the thing is, I'm not against resumes, or portfolios, or other things of the sort. I'm against websites existing simply because people want to paint themselves as more educated or qualified than they really are. That is, I'm against these things serving as a marketing medium, not the things themselves.

Here's how I view it: an ethically constructed resume or CV accurately records skills, experiences and qualifications for an individual without embellishing or misrepresenting. It is concise, factual, and descriptive. It is not vague and does not promise more than what is there. A person should be prepared to defend the exact wording of every phrase included in the document without qualification.

The same thing would go for the now-ubiquitous "elevator pitch." It is a decidedly good thing to be able to briefly summarize why you are an attractive value proposition -- to objectively lay out what things you bring to the table. But there should not be rhetoric or showboating or anything like that in this. It should be kept matter-of-fact. And people who lie or misrepresent themselves in any part of the job-seeking process should be punished swiftly and severely.

### On Naming Websites

Having an uncommon enough last name let me obtain firstlast.com, which I think is ideal. Several people have told me that they think it is really pretentious to have a website named after myself, but I would contend that that is simply a bias people hold because of all the stupid self-promoting websites scorned above.

The thing common to this website is me. I don't have any one particular interest, so a website named after any one of them singularly (e.g., efficient-text-entry.com) would prove to be misleading in many circumstances. An arbitrarily name works fine for large companies (e.g., Amazon) or specific projects (e.g., [hypothes.is](https://web.hypothes.is/)), but doesn't make a lot of sense for individuals.

If you make a habit of tooting your own horn in everything you write then that is obnoxious and you should stop. But I'm not going to change my website name to something unrelated to my personal name (or feel bad about setting things up this way) since I am the thing that most clearly ties all the content together on this site: these are *my* thoughts.

### On Anonymity

Some people also argue for writing anonymously. I'm not one of them. If you don't have the guts to put your name behind what you are writing, then you probably shouldn't be writing it. Getting "doxxed" is only a problem if you aren't enough of a man (or woman) to associate your name with your views.

Letting people know who you really are is actually something *in support of* posting a CV/Resume, portfolio, etc. I use heuristics a lot to decide who I should even contemplate listening to, and to me, not knowing the real author of something is more of a red flag than learning that the author had 2.7 GPA and and dropped out of college.

Why? Because, for example, people drop out of college for all kinds of reasons. They get fed up with the political correctness and mysterious expense categories they have no control over. They get sick of watching how the University pats itself on the back for its students' successes when usually said students succeeded almost entirely on their own drive and determination, sometimes despite the University.

Now don't get me wrong. The brokenness of higher education (and validity of MOOCs and experiential learning) does not equate into a blanket condemnation of the system. (This is ultimately a topic for a separate post). What I was getting at is that people and circumstances are complicated, and I at least won't arbitrarily judge them without hearing their take on their path. But people who won't give any information about themselves? My first instinct (verified through experience over time) is to think that they're hiding something.

## Using PuTTY and Emacs' Tramp On Windows

### Table of Contents

- [Introduction and Motivation](#introduction-and-motivation)
- [Step One: Install Emacs and PuTTY](#step-one-install-emacs-and-putty)
- [Step Two: Familiarize Yourself With Relevant Emacs Commands](#step-two-familiarize-yourself-with-relevant-emacs-commands)
- [Step Three: Set Up SSH Keys](#step-three-set-up-ssh-keys)
- [Step Four: Optional Optimizations](#step-four-optional-optimizations)

### Introduction and Motivation

Windows doesn't support a lot of common Unix commands, `ssh` included.

There are several ways to overcome this fact. The [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10) is one option. I've used it and it's certainly a big step up over native windows shells. But to get any GUI applications you have to set up an X server or somesuch (to my knowledge -- which is admittedly limited at present). It's also a bit of a pain to interface natively with normal Windows files, since you have to use `/mnt/c/` to get to to them. This doesn't matter so much if you are a poweruser who lives in the terminal, but even those of us headed in that direction may not want a system entirely separate from our normal computing environment.

[Cygwin](https://cygwin.com/) is another option. You can use the Cygwin bash shell just like any other bash shell, and most commands will work seamlessly since they are all compiled natively. However, you again have special notation for handling normal Windows files: `cygdrive/c/`. I didn't have any problems getting Cygwin set up (some people reportedly find it fidgety and difficult), nor did I have issues using the versions of vim and emacs that come with it. You may have to adjust Environment Variables and your Path to be able to invoke binaries globally. See this [stackoverflow thread](https://stackoverflow.com/questions/14797194/cygwin-ls-command-not-found).

You can install things like updated text editors (e.g., Spacemacs, NeoVim) and different shells (fish, zsh) in these configurations, if you so wish. They are basically POSIX-compatible environments on Windows, with some limitations. You can, of course, also run a full Linux distribution on a virtual machine, or partition your hard drive to boot to one. I'm planning on setting up Ubuntu or Mint for myself in the near future to obviate the need for some of this hackiness to make Windows something it's not.

Anyhow, all this isn't necessarily what this post is going to focus on -- this was all to establish the fact that it's possible to get SSH outside of the configuration described below, and that some people may find other things equal or better for their purposes. YMMV, as they say. (Note that the below focuses on native Windows emacs, but you can easily set up something similar with Cygwin emacs, at least I'd assume so).

What I want is to be able to access my Windows files normally, and to use [Tramp](https://www.emacswiki.org/emacs/TrampMode) with SSH keys to automagically log me in whenever I use `find-file` to open a file with a remote path. And I want to be able to do this within emacs so that I can use my evil mode vim-fu on the command line and when going through history and so forth.

I don't have anything against using remote shells and local editors at the present time (you can get evil mode vim-fu through local terminal emacs too, for example), but the more configuration and customization I build up, the more important it will be for me to have *my* configuration -- all my shell aliases, font and powerline customizations, autocompletion and expansion packages, etc. -- accessible to me at all times. I don't want to limit myself to vanilla bash and vim because that's all that comes preinstalled on many servers; some of these things are not just pretty colors and fonts, but serious productivity improvements. Sure, bash may be "good enough." But I don't like "good enough," I like "as good as can possibly be given practical constraints." So setting up a system such that I will always have the same, consistent, efficient system of my choosing only makes sense.

### Step One: Install Emacs and PuTTY

You don't have to do it from the command line. I'd recommend you get a high quality (i.e., optimized) Windows emacs build from [this maintained project](https://sourceforge.net/projects/emacsbinw64/). You can get PuTTY from [the official site](https://www.putty.org/).

When installing PuTTY, make sure you check the box that lets you add the programs to your Path.

### Step Two: Familiarize Yourself With Relevant Emacs Commands

If you want to use vim bindings in emacs, I suggest you install [Spacemacs](https://github.com/syl20bnr/spacemacs). I got it up and running in short order, and it makes it really easy to extend functionality with layers.

Otherwise, you can stay with vanilla (chord-heavy) emacs. You can still use Tramp and so forth with vanilla emacs.

Here's a good list of basic commands to get started:

| Command                               | Spacemacs                        | Vanilla Emacs   |
| ------------------------------------- | -------------------------------- | --------------- |
| Find file                             | `Spc f f`                        | `C-x C-f`       |
| Use PuTTY to SSH to a remote server   | `plink user@host`                | identical usage |
| Access remote file with Tramp + PuTTY | `/plink:user@host:/path/to/file` | identical usage |
| Save buffer                           | `Spc f s`                        | `C-x C-s`       |
| Close buffer                          | `Spc b d`                        | `C-x k`         |
| Open eshell                           | `Spc Spc eshell`                 | `M-x eshell`    |
| Open system shell with M-x shell      | `Spc Spc shell`                  | `M-x shell`     |

In the commands above, `Spc Spc` is Spacemacs' equivalent to `M-x`. In Spacemacs, you can also open your default shell type with `Spc '`. You can customize this with code in your .spacemacs file. For example, to make eshell the default shell:

```lisp
(setq-default dotspacemacs-configuration-layers
  '((shell :variables shell-default-shell 'eshell)))
```

There are other shell options in Spacemacs. Check out [the documentation](https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Btools/shell). 

I'm using eshell since it integrates with Tramp seamlessly, allows for completely normal accessing of Windows files, and automatically switches to remote directories when you are editing a file in one. There are some performance considerations, however, so I wouldn't recommend using it for long compile commands, long `cat` commands, or anything else that dumps a bunch of text to console; using it to pipe large amounts of data from process to process; or using it for interactive programs -- e.g., `htop`, `nano`, other ncurses programs -- that require cursor control (since it simply doesn't support these). You can use a system shell in a real terminal emulator for such things, without an emacs layer over the top slowing things down or making them more complicated.

With all this being said, eshell can run lisp in-line (serving as a lisp REPL of sorts), has access to all the emacs functions straight from the command line, and is extremely hackable. (You can totally customize globbing and predication, for example). So you can use it most of the time for its advantages, and switch to a system shell in a terminal emulator when doing so is the superior choice.

### Step Three: Set Up SSH Keys

Tramp works great for not having to bother with the nitty-gritty details of remote files and editing. However,  it quickly gets old entering your password for the remote server all the time. SSH keys can handle this problem, to make Tramp use truly effort-free.

[Here is a guide for setting up PuTTY SSH keys to automate login](https://www.howtoforge.com/ssh_key_based_logins_putty). I recommend setting an SSH password and using Pageant to automatically enter it, as they suggest, since it is more secure. It is not necessary to disable password-based login on your remote server. (It's a bad idea for me, for example, since school IT people would be angry if I locked myself out).

### Step Four: Optional Optimizations

Accessing files directly with Tramp certainly beats always having to keep track of remote shells and sessions. But it is still a bit of a pain typing out something like `/plink:nike:/path/to/file` whenever I want to access a remote file. There is also the irritating fact that using, e.g., `Spc f f` starts you off in the current directory, and on Windows, starting a path with `/` will leave a `c:/` prepended (which you have to delete when entering a remote file path).

To make it all easier, I wrote a simple Authotkey hotstring to expand out pl{Spc} to /plink:nike:~/ (nike is the name in PuTTY I gave the remote connection to my school's servers, tammen@nike.cs.uga.edu). It's smart enough to delete the c:/, and it even includes some delay before starting on the remote file path to give helm (an autocompletion package that I use in Spacemacs) time to catch up. You can, of course, include this in part of a larger Autohotkey script (i.e., one that does other things too). Here's the code:

```
; Defines a hotstring for a PuTTY remote connection called 'nike'
:o:pl::
	SendInput {Backspace 3}/plink:nike:
	Sleep 1000
	SendInput ~/
	return
```

The last thing you may want to do is add this autohotkey script and the shortcut to activate Pageant to your Windows startup sequence so that all this stuff happens automatically.
